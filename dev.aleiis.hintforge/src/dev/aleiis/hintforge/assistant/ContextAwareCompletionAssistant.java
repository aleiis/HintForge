package dev.aleiis.hintforge.assistant;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import dev.aleiis.hintforge.model.ContextAwareCompletionConfig;
import dev.aleiis.hintforge.model.DslProfile;
import dev.langchain4j.service.SystemMessage;
import dev.langchain4j.service.UserMessage;
import dev.langchain4j.service.V;

interface ContextAwareCompletionService {
	@SystemMessage("""
			## INSTRUCTIONS
			- You are a code-completion assistant specialized in Domain-Specific Languages (DSLs).
			- Locate the marker `[[CURSOR]]` in the userâ€™s code and return **only** the fragment that should replace it.
			  - Do not include `[[CURSOR]]` itself.
			  - Do not return any surrounding lines or extra tokens, only the minimal code needed for completion.
			  - Do not enclose the fixed fragment in backticks.
			- Your suggestion must satisfy the user's instruction.
			- Your suggestion must be syntactically valid and semantically meaningful according to the provided DSL grammar.
			- Do not add comments, explanations, or any text beyond the completion fragment.
			- Only generate code that conforms to the given DSL specification; do not invent constructs outside of its grammar.

			## DSL
			Name: {{name}}
			Description: {{description}}
			Grammar:
			{{grammar}}

			## EXAMPLE SCRIPTS
			{{examples}}
			      """)
	String chat(@UserMessage String userMessage, @V("name") String name, @V("description") String description,
			@V("grammar") String grammar, @V("examples") String examples, @V("code") String code,
			@V("instruction") String instruction);
}

interface FixErrorsContextAwareCompletionService {
	@SystemMessage("""
			## INSTRUCTIONS
			- You are a code-repair assistant specialized in Domain-Specific Languages (DSLs).
			- Your job is to fix syntactic errors in code fragments generated by other models. These fragments may cause parsing failures or overlap incorrectly with existing code.
			- You will be given:
				- A full source code that contains the generated fragment.
				- The exact generated fragment.
				- A list of syntax errors from the DSL parser.
			- You must repair the **generated fragment** so that it becomes syntactically valid according to the grammar.
			- Remove duplicated or overlapping fragments.
			- Ensure the resulting code is minimal, consistent, and conforms strictly to the DSL grammar.
			- You must only return the **corrected code** (not a diff or explanation).
			- Do not invent constructs not present in the DSL grammar.
			- Do not add any comments or explanations.
			- Do not enclose the fixed fragment in backticks.

			## DSL
			Name: {{name}}
			Description: {{description}}
			Grammar:
			{{grammar}}

			## EXAMPLE SCRIPTS
			{{examples}}
			      """)
	String chat(@UserMessage String userMessage, @V("name") String name, @V("description") String description,
			@V("grammar") String grammar, @V("examples") String examples);
}

public class ContextAwareCompletionAssistant extends Assistant {

	private static Logger logger = LoggerFactory.getLogger(ContextAwareCompletionAssistant.class);

	public ContextAwareCompletionAssistant(String openAiApiKey, DslProfile dsl) {
		super(openAiApiKey, dsl);
	}

	public ContextAwareCompletionAssistant(String openAiApiKey, DslProfile dsl, String modelName) {
		super(openAiApiKey, dsl, modelName);
	}

	public ContextAwareCompletionAssistant(Path homeFolder, String openAiApiKey, DslProfile dsl, String modelName) {
		super(homeFolder, openAiApiKey, dsl, modelName);
	}

	/**
	 * Method used to generate a new suggestion.
	 * 
	 * @param instruction User's instructions.
	 * @param code        Context of the code.
	 * @param offset      Offset in the code where the code suggestion must be
	 *                    inserted.
	 * 
	 * @return The suggested code.
	 * 
	 * @throws IOException If there was an error reading the Xtext file.
	 */
	public String suggest(String instruction, String code, int offset) {
		DslProfile dsl = this.getDslProfile();
		ContextAwareCompletionConfig config = dsl.getCodeCompletionConfig();

		String grammar;
		try {
			grammar = dsl.getXtextFile().readContent(getHomeFolder());
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}

		String markedCode = code.substring(0, offset) + "[[CURSOR]]" + code.substring(offset);

		String examples = buildExamplesString();
		if (examples == null) return null;

		int maxGenerationAttempts = config.getMaxGenerationAttempts();
		int maxFixAttempts = config.getMaxFixAttempts();

		logger.debug("GENERATING A NEW SUGGESTION");

		String suggestion = "";
		List<String> errors;
		for (int generationAttempt = 0; generationAttempt < maxGenerationAttempts; generationAttempt++) {

			double temperature = (generationAttempt == 0) ? 0.3 : 0.5;

			ContextAwareCompletionService codeCompletionService = buildAssistant(ContextAwareCompletionService.class,
					temperature);

			suggestion = codeCompletionService.chat(config.getFewShotPrompt(), dsl.getName(), dsl.getDescription(),
					grammar, examples, markedCode, instruction);
			logger.debug(String.format("Suggestion generated (generationAttempt: %d) -->\n%s", generationAttempt,
					suggestion));

			errors = buildAndVerify(code, offset, suggestion);
			if (errors.isEmpty()) {
				logger.debug("Suggestion accepted!");
				return suggestion;
			} else {
				logger.debug(String.format("Parsing errors found (generationAttempt: %d) -->\n%s", generationAttempt,
						errors.stream().reduce((a, b) -> a + "\n" + b)));
			}

			for (int fixAttempt = 0; fixAttempt < maxFixAttempts; fixAttempt++) {

				suggestion = trimContextOverlap(code, offset, suggestion);
				logger.debug(String.format("Suggestion trimmed (generationAttempt: %d, fixAttempt: %d) -->\n%s",
						generationAttempt, fixAttempt, suggestion));

				errors = buildAndVerify(code, offset, suggestion);
				if (errors.isEmpty()) {
					logger.debug("Suggestion accepted!");
					return suggestion;
				} else {
					logger.debug(String.format(
							"Parsing errors found after trimming (generationAttempt: %d, fixAttempt: %d) -->\n%s",
							generationAttempt, fixAttempt, errors.stream().reduce((a, b) -> a + "\n" + b)));
				}

				suggestion = fixSuggestion(code, offset, suggestion, errors, temperature);
				if (suggestion == null) return null;
				logger.debug(String.format("Suggestion fixed (generationAttempt: %d, fixAttempt: %d) -->\n%s",
						generationAttempt, fixAttempt, suggestion));

				errors = buildAndVerify(code, offset, suggestion);
				if (errors.isEmpty()) {
					logger.debug("Suggestion accepted!");
					return suggestion;
				} else {
					logger.debug(String.format(
							"Parsing errors found after fixing (generationAttempt: %d, fixAttempt: %d) -->\n%s",
							generationAttempt, fixAttempt, errors.stream().reduce((a, b) -> a + "\n" + b)));
				}
			}
		}

		logger.debug(
				String.format("No valid suggestion found in %d generation attempts with %d fixing attempts each...",
						maxGenerationAttempts, maxFixAttempts));

		suggestion = trimContextOverlap(code, offset, suggestion);
		logger.debug(String.format("Suggestion after last trimming -->\n%s", suggestion));

		errors = buildAndVerify(code, offset, suggestion);
		if (errors.isEmpty()) {
			logger.debug("Suggestion accepted!");
			return suggestion;
		} else {
			logger.debug(String.format("Parsing errors found after the last trimming -->\n%s",
					errors.stream().reduce((a, b) -> a + "\n" + b)));
		}

		logger.debug("Returning the last suggestion...");
		return suggestion;
	}

	private String fixSuggestion(String code, int offset, String suggestion, List<String> errorList, Double temperature) {

		DslProfile dsl = this.getDslProfile();

		String grammar;
		try {
			grammar = dsl.getXtextFile().readContent(getHomeFolder());
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}

		String completedCode = code.substring(0, offset) + suggestion + code.substring(offset);
		String errors = errorList.stream().reduce("", (a, b) -> a + "\n" + b);
		String userMessage = String.format("""
				FULL CODE:
				%s
				GENERATED FRAGMENT:
				%s
				ERRORS:
				%s
				FIXED FRAGMENT:

				""", completedCode, suggestion, errors);

		String examples = buildExamplesString();
		if (examples == null) return null;

		FixErrorsContextAwareCompletionService aiService = buildAssistant(FixErrorsContextAwareCompletionService.class,
				temperature);

		return aiService.chat(userMessage, dsl.getName(), dsl.getDescription(), grammar, examples);
	}

	private List<String> buildAndVerify(String code, int offset, String suggestion) {
		String completedCode = code.substring(0, offset) + suggestion + code.substring(offset);
		return getVerifier().validate(completedCode, true);
	}
}
